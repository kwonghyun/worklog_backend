## 업무의 기록과 일정 관리를 하는 메모 웹, 워크로그



![image-20240207001441527](C:\Users\Gwanghyun\AppData\Roaming\Typora\typora-user-images\image-20240207001441527.png)

last updated at: 2024.02.12





### 목차

------

- [프로젝트 설명](#프로젝트-설명)
- [실행 방법](#실행-방법)
- [사용 방법](#사용-방법)
- [요구 사항](#요구-사항)
- [중점 구현 사항](#중점-구현-사항)













### 프로젝트 설명

------

#### 개요

- 웹사이트 주소 : https://today.worklog.shop (임시 계정 ID: 3, PW: 3)

- API 서버: https://worklog.shop

- API 명세서 : [구글 스프레드 시트](https://docs.google.com/spreadsheets/d/1ELjduGpp7mbwTTfVWQHOoaWxEAEbjf6rfnRuwG0GM5Y/edit#gid=0)
- 개발 인원 : 백엔드 1인(<img src="https://github.githubassets.com/assets/GitHub-Mark-ea2971cee799.png" width="30" height="28"> [본인](https://github.com/kwonghyun/worklog_backend)), 프론드엔드 1인 (<img src="https://github.githubassets.com/assets/GitHub-Mark-ea2971cee799.png" width="30" height="28">[dmchoi77](https://github.com/dmchoi77/worklog))

- 개발 기간: 2023.11.10 ~ 진행중

#### 개발환경

- 언어 : Java17
- 빌드 툴 : Gradle
- 프레임워크 : Springboot(3.1.x), Spring Framework, 
  Spring Data JPA, Spring Security, Spring AOP, Spring Validation
- 라이브러리: Quartz Scheduler(알림 기능), Quarydsl
- ORM : JPA
- DB: MySQL
- 프록시서버: nginx
- 캐시 서버(리프레시 토큰): Redis
- Infra Structure: AWS(EC2, RDS, CodeDeploy, S3), GIthub Actions

#### ERD

<img src="C:\Users\Gwanghyun\AppData\Roaming\Typora\typora-user-images\image-20240206235827465.png" alt="image-20240206235827465" style="zoom:35%;" />

#### 프로젝트 구조

![image-20240206200557127](C:\Users\Gwanghyun\AppData\Roaming\Typora\typora-user-images\image-20240206200557127.png)

#### 배포 구조

![image-20240206200639822](C:\Users\Gwanghyun\AppData\Roaming\Typora\typora-user-images\image-20240206200639822.png)

[목차](#목차)











### 실행 방법

------

로컬 실행시 

1. IntelliJ, MySQL 8.0 설치
2. redis 클라이언트 설치
   - Windows 사용자: https://github.com/microsoftarchive/redis/releases에서 .msi 파일 설치
   - Mac 사용자: ```brew install redis```
3. 환경변수 설정
   - JWT_EXPIRATION : 엑세스 토큰 유효시간(초)
   - JWT_REFRESH_EXPIRATION : 리프레시토큰 유효시간(초)
   - JWT_SECRET : JWT 시크릿 키(임의 문자열)
   - LOCAL_DB_URL : MySQL 스키마 URL
   - LOCAL_DB_USERNAME :  MySQL 사용자 이름
   - LOCAL_DB_PASSWORD : MySQL 비밀번호
4. 프로필 설정
   - Active Profiles: dev

5. 실행

[목차](#목차)

### 요구 사항

------

- 업무 마감 임박 알림(프론트 미구현)
  - 생성된 업무가 알림을 보낼 시간이 지났다면 바로 알림을 전송합니다.
  - 생성된 업무의 알림을 보낼 시간이 24시간 이내라면 알림을 예약합니다.
  - 업무의 생성 또는 수정이 발생하면 알림을 동작할지 확인합니다.
- 회원
  - 로그인 및 회원가입을 할 수 있습니다.
  - 로그인된 사용자에 한해 서비스를 이용할 수 있습니다.
- 업무
  - 사용자는 해당일의 업무를 생성/조회/수정/삭제 할 수 있습니다.
  - 업무에는 제목, 내용, 업무유형, 진행상태를 포함합니다. 
  - 날짜별로 업무가 표시되는 순서를 저장할 수 있습니다.
  - 제목, 내용을 검색할 수 있습니다.
- 메모
  - 사용자는 해당일의 메모를 생성/조회/수정/삭제 할 수 있습니다.
  - 메모에는 내용만 기록할 수 있습니다.
  - 날짜별로 메모가 표시되는 순서를 저장할 수 있습니다.
  - 내용을 검색할 수 있습니다.
  
- 달력
  - 업무 또는 메모가 존재하는 년월일에 한해 날짜를 제공합니다.
  - 날짜는 년월일 순으로 제공됩니다.

[목차](#목차)

### 중점 구현 사항

------

#### 알림 기능

![업무생성수정삭제시](C:\Users\Gwanghyun\Desktop\worklog 다이어그램\업무생성수정삭제시.png)

![토큰발급시](C:\Users\Gwanghyun\Desktop\worklog 다이어그램\토큰발급시.PNG)

![SSE연결시](C:\Users\Gwanghyun\Desktop\worklog 다이어그램\SSE연결시.PNG)



#### DB 접근 최소화

- Refresh Token을 Redis에 저장해 Access Token 재발급시 DB접근 불필요

- JWT에 userId를 담아 user 테이블과 조인하는 모든 쿼리 FK로만 조회

- 로그인, 회원가입, 비밀번호 변경 시 ID/PW가 형식에 맞지 않으면 DB 조회하지 않고 로그인 실패 처리
  ```java
  public class UserService {
  	// ...
  	public JwtDto login(UserLoginDto dto, HttpServletRequest request) {
          Pattern usernamePattern = Pattern.compile(Constant.USERNAME_REGEX);
          Pattern passwordPattern = Pattern.compile(Constant.PASSWORD_REGEX);
          if (
                  !usernamePattern.matcher(dto.getUsername()).matches()
                  || !passwordPattern.matcher(dto.getPassword()).matches()
          ) {     
              throw new CustomException(ErrorCode.LOGIN_FAILED);            
          }
  		// 이후 ID/PW 확인 및 토큰 발급...
      }
      // ...
  }
  ```

  

#### 느슨한 결합

- 업무 생성·수정·삭제 시 알림 조건 확인 및 전송 로직에 EventPublisher·Listener 적용

  ```java
  public class WorkService{   
      // ...
      public void createWork(WorkPostDto dto, CustomUserDetails userDetails) {
          Work work = workRepository.save(
                  Work.builder()
                         //...
                          .build()
          );
          // JPA에서 Flush 후 이벤트 발행
          applicationEventPublisher.publishEvent(
                  WorkChangeEvent.builder().work(work).build()
          );
      }
      // ...
  }
  ```

  ```java
  public class EventHandler {
      private final NotificationService notificationService;
      @EventListener
      // 이벤트 받아 로직 실행
      public void onWorkChanged(WorkChangeEvent workChangeEvent) {
          Work work = workChangeEvent.getWork();
          Long userId = work.getUser().getId();
          //... 조건 확인 후 전송하거나 알림 예약
  		Notification notification = notificationService.createNotificationFrom(work);
  		notificationService.sendNotification(notification);
  }
  ```

  

#### 응답 통일

- 응답 형식

  - 자원을 반환하는 응답
    ```json
    {"status": 200,
     "count": 0,
     "data": []}
    ```

  - 자원을 반환하지 않는 모든 응답(예외 포함)

    ```json
    {"status": 201,
     "code": "CREATED",
     "message": "업무일지가 생성되었습니다."}
    ```



- 응답 처리 방식

  - 스프링 안에서 발생하는 예외 : @RestControllerAdvice으로 처리

    - 사용자 지정 예외 : CustomException 클래스 생성해 사용
      ```java
      @ExceptionHandler(CustomException.class)
      protected ResponseEntity handleCustomException(CustomException ex) {
      	return new ResponseEntity(
                  ResponseDto.fromErrorCode(
                      ex.getErrorCode()), 
                  	HttpStatus.valueOf(ex.getErrorCode().getStatus()));
      }
      ```

    - Validation에서 발생하는 예외
      ```java
      @ExceptionHandler(MethodArgumentNotValidException.class)
      @ResponseStatus(HttpStatus.BAD_REQUEST)
      protected ResponseDto handleValidationException(
              MethodArgumentNotValidException exception
      ) {
              return ResponseDto.fromValidationException(exception);
      }
      ```

    - 그 외의 예외
      ```java
      @ExceptionHandler(Exception.class)
      protected ResponseEntity handleServerException(Exception ex) {
          return new ResponseEntity(
          	ResponseDto.fromErrorCode(INTERNAL_SERVER_ERROR), 		
          	HttpStatus.INTERNAL_SERVER_ERROR);
          }
      ```

      

  - 스프링 밖에서 발생하는 예외

    - 필터 실행중 발생하는 예외: ObjectMapper 사용
      ex) JWT 파싱중 예외 응답해 401 응답시 프론트에서 토큰 재발급 요청

      ```java
      public class FilterExceptionHandler {
          public static void jwtExceptionHandler(
              HttpServletResponse response, ErrorCode error
          ) {
              response.setStatus(error.getStatus());
              response.setContentType(MediaType.APPLICATION_JSON_VALUE);
              response.setCharacterEncoding("UTF-8");
              try {
                  ObjectMapper objectMapper = new ObjectMapper();
                  objectMapper.writeValue(response.getWriter(), ResponseDto.fromErrorCode(error));
              } catch (Exception e) {
                  log.error(e.getMessage());
              }
          }
      }
      ```

    - 그 외의 예외 : DefaultErrorAttributes 상속
      ex) 맵핑되지 않은 Request URI

      ```java
      @Component
      public class CustomErrorAttributes extends DefaultErrorAttributes {
          @Override
          public Map<String, Object> getErrorAttributes(
          	WebRequest webRequest, ErrorAttributeOptions options
          ) {
              ResponseDto responseDto = ResponseDto.fromErrorAttributes(
                      super.getErrorAttributes(webRequest, options)
              );
              return BeanMap.create(responseDto);
          }
      }
      ```



[목차](#목차)

